"""
Kitchen-sink schema that demonstrates all GraphQL features:
- Scalar types (built-in and custom)
- Object types with various field types
- Input types
- Interfaces
- Unions
- Enums
- Directives
- Lists and non-null variations
"""
scalar # Custom scalar types
Date
scalar JSON
scalar Upload

# Directives
directive @deprecated(reason: String) on FIELD_DEFINITION | ENUM_VALUE
directive @auth(requires: Role!) on FIELD_DEFINITION
directive @cacheControl(
  maxAge: Int!
  scope: CacheControlScope
) on FIELD_DEFINITION | OBJECT | INTERFACE

# Enum definitions
enum Role {
  ADMIN
  USER
  GUEST
}

enum CacheControlScope {
  PUBLIC
  PRIVATE
}

enum PostStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

# Interface definitions
interface Node {
  id: ID!
}

interface Timestamped {
  createdAt: Date!
  updatedAt: Date
}

interface Searchable {
  searchableFields: [String!]!
}

# Union types
union SearchResult = User | Post | Comment | Product

union MediaItem = Image | Video | Document

# Input types
input UserInput {
  name: String!
  email: String!
  role: Role = USER
  profile: ProfileInput
  preferences: JSON
}

input ProfileInput {
  bio: String
  avatar: String
  socialLinks: [SocialLinkInput!]
}

input SocialLinkInput {
  platform: String!
  url: String!
}

input SearchInput {
  query: String!
  filters: [FilterInput!]
  pagination: PaginationInput
}

input FilterInput {
  field: String!
  operator: FilterOperator!
  value: String!
}

input PaginationInput {
  page: Int = 1
  pageSize: Int = 10
}

# Enum for filter operators
enum FilterOperator {
  EQ
  NEQ
  GT
  GTE
  LT
  LTE
  CONTAINS
  STARTS_WITH
  ENDS_WITH
}

# Complex object types
type User implements Node & Timestamped & Searchable {
  id: ID!
  name: String!
  email: String!
  role: Role!
  profile: Profile
  posts: [Post!]
  comments: [Comment!]
  followers: [User!]
  following: [User!]
  createdAt: Date!
  updatedAt: Date
  searchableFields: [String!]!
  settings: JSON
  lastLogin: Date
  meta: [MetadataItem!]
}

type Profile {
  bio: String
  avatar: String
  socialLinks: [SocialLink!]
}

type SocialLink {
  platform: String!
  url: String!
}

type Post implements Node & Timestamped & Searchable {
  id: ID!
  title: String!
  content: String!
  excerpt: String
  status: PostStatus!
  author: User!
  categories: [Category!]!
  tags: [Tag!]
  comments: [Comment!]
  media: [MediaItem!]
  createdAt: Date!
  updatedAt: Date
  publishedAt: Date
  searchableFields: [String!]!
  viewCount: Int!
  likeCount: Int!
  metadata: JSON
}

type Comment implements Node & Timestamped {
  id: ID!
  content: String!
  author: User!
  post: Post!
  parentComment: Comment
  childComments: [Comment!]
  createdAt: Date!
  updatedAt: Date
  isEdited: Boolean!
  reactions: [Reaction!]
}

type Category implements Node {
  id: ID!
  name: String!
  description: String
  parentCategory: Category
  childCategories: [Category!]
  posts: [Post!]
}

type Tag implements Node {
  id: ID!
  name: String!
  posts: [Post!]
}

type Image implements Node {
  id: ID!
  url: String!
  alt: String
  width: Int!
  height: Int!
  format: String!
  size: Int!
}

type Video implements Node {
  id: ID!
  url: String!
  title: String
  duration: Int!
  thumbnail: Image
  format: String!
  size: Int!
}

type Document implements Node {
  id: ID!
  url: String!
  title: String
  fileType: String!
  size: Int!
  pageCount: Int
}

type Reaction {
  id: ID!
  type: String!
  user: User!
}

type Product implements Node & Timestamped & Searchable {
  id: ID!
  name: String!
  description: String
  price: Float!
  currency: String!
  inventory: Int!
  categories: [Category!]
  images: [Image!]
  variants: [ProductVariant!]
  reviews: [Review!]
  createdAt: Date!
  updatedAt: Date
  searchableFields: [String!]!
  specifications: JSON
}

type ProductVariant {
  id: ID!
  name: String!
  price: Float!
  attributes: [ProductAttribute!]!
  inventory: Int!
}

type ProductAttribute {
  name: String!
  value: String!
}

type Review implements Node & Timestamped {
  id: ID!
  rating: Int!
  content: String
  author: User!
  product: Product!
  helpfulCount: Int!
  createdAt: Date!
  updatedAt: Date
}

type MetadataItem {
  key: String!
  value: String!
}

# Pagination type
type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

# Connection pattern for pagination
type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserEdge {
  node: User!
  cursor: String!
}

type PostConnection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PostEdge {
  node: Post!
  cursor: String!
}

# Root types
type Query {
  # Node interface query
  node(id: ID!): Node

  # User queries
  user(id: ID!): User
  users(pagination: PaginationInput): UserConnection!
  me: User

  # Post queries
  post(id: ID!): Post
  posts(
    status: PostStatus
    authorId: ID
    categoryId: ID
    pagination: PaginationInput
  ): PostConnection!

  # Search
  search(input: SearchInput!): [SearchResult!]!

  # Category queries
  category(id: ID!): Category
  categories: [Category!]!

  # Product queries
  product(id: ID!): Product
  products(categoryId: ID, pagination: PaginationInput): [Product!]!

  # Miscellaneous
  statistics: JSON!
  healthCheck: Boolean!
}

type Mutation {
  # User mutations
  createUser(input: UserInput!): User!
  updateUser(id: ID!, input: UserInput!): User!
  deleteUser(id: ID!): Boolean!

  # Authentication mutations
  login(email: String!, password: String!): AuthPayload!
  refreshToken(token: String!): AuthPayload!

  # Post mutations
  createPost(
    title: String!
    content: String!
    excerpt: String
    status: PostStatus = DRAFT
    categoryIds: [ID!]!
    tagIds: [ID!]
  ): Post!
  updatePost(
    id: ID!
    title: String
    content: String
    excerpt: String
    status: PostStatus
    categoryIds: [ID!]
    tagIds: [ID!]
  ): Post!
  deletePost(id: ID!): Boolean!

  # Comment mutations
  addComment(postId: ID!, content: String!, parentCommentId: ID): Comment!
  updateComment(id: ID!, content: String!): Comment!
  deleteComment(id: ID!): Boolean!

  # Product mutations
  createProduct(
    name: String!
    description: String
    price: Float!
    currency: String = "USD"
    inventory: Int!
    categoryIds: [ID!]
    specifications: JSON
  ): Product!

  # File upload
  uploadFile(file: Upload!): MediaItem!
}

type Subscription {
  userUpdated(id: ID): User!
  postCreated(categoryId: ID): Post!
  commentAdded(postId: ID!): Comment!
  notification: JSON!
}

type AuthPayload {
  token: String!
  refreshToken: String!
  user: User!
  expiresIn: Int!
}
